/*
 * Copyright 2014, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(NICTA_GPL)
 */

/* CAmkES ADL description of the system. Every system needs such a description
 * that covers the component types, their instantiations, connections between
 * them and system configuration. This description can be split across multiple
 * files, using the 'import' directive that works like CPP's #include
 * directive. For simplicity, I've just defined everything in a single file.
 */

/* Import builtin ADL descriptions of CAmkES connector types. */
import <std_connector.camkes>;

/* Interface definitions: */

/* Component definitions: */

/* The serial device needs to be declared as a hardware component. We describe
 * the memory region containing its I/O registers using the default dataport
 * type Buf, that represents a 4K-page-sized region. The physical address of
 * this region is described in the configuration block below.
 */
component SerialDevice {
    hardware;
    dataport Buf ioregisters;
}

/* The serial device driver will configure the serial device, and then
 * communicate with it and the switch. Below we will connect its dataport to
 * the serial device and its outgoing interface to the switch.
 */
component SerialDriver {
    /* The 'control' keyword gives this component a thread that will call the
     * function run() implemented by the user.
     */
    control;
    dataport Buf device_registers;
    dataport Buf char_out;
}

component Switch {
    control;
    dataport Buf char_in;
    dataport Buf low_output;
    dataport Buf high_output;
}

/* Placeholder for virtualised Linux. */
component MockLinux {
    control;
    dataport Buf keyboard_input;
    dataport Buf framebuffer;
}

component VESADriver {
    control;
    dataport Buf low_input;
    dataport Buf high_input;
    /* Rather than implementing a full HDMI driver, for now we just use the
     * serial console output to mock up what communication and output would
     * look like.
     */
    dataport Buf mock_hdmi;
}

/* The system definition: */
assembly {
    composition {
        /* Instantiate each component type once. There is actually syntax for
         * creating these as singleton types, but we don't use it here because
         * it leads to a more dense, complicated description.
         */
        component SerialDevice dev;
        component SerialDriver serial;
        component Switch s; /* XXX: Remember not to call a component like this
                             * 'switch' as it will collide with the C keyword.
                             */

        /* In the real system, we would have an actual HDMI device, but we're
         * just using the serial console as output for a proof of concept.
         */
        component SerialDevice video;
        component VESADriver vesa;

        /* Instantiate two Linuxes. */
        component MockLinux low;
        component MockLinux high;

        /* Wire everything up. */
        connection seL4HardwareMMIO keyboard(from serial.device_registers, to dev.ioregisters);
        connection seL4SharedData text(from serial.char_out, to s.char_in);
        connection seL4SharedData low_text(from s.low_output, to low.keyboard_input);
        connection seL4SharedData high_text(from s.high_output, to high.keyboard_input);
        connection seL4SharedData low_video(from low.framebuffer, to vesa.low_input);
        connection seL4SharedData high_video(from high.framebuffer, to vesa.high_input);
        connection seL4HardwareMMIO video_out(from vesa.mock_hdmi, to video.ioregisters);
    }

    /* This section is used to make tweaks to the system described above. Below
     * we describe the physical address of the serial device's control
     * registers that we will need to access. During the build process this
     * information is passed to the CapDL loader to tell it which frames to map
     * in.
     */
    configuration {
        /* XXX: This address is for the KZM's serial port. We'll need to alter
         * this when moving to the Sabre/Arndale/etc.
         */
        dev.ioregisters_attributes = "0x43f90000:0x1000";
        video.ioregisters_attributes = "0x43f90000:0x1000";

        /* We want to make each dataport effectively a data diode by ensuring
         * one way communication. To do this, set each of the dataport's to
         * sides to read-only access.
         */
        text.to_access = "R";
        low_text.to_access = "R";
        high_text.to_access = "R";
        low_video.to_access = "R";
        high_video.to_access = "R";
    }
}
